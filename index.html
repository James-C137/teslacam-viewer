<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tesla Telemetry - Video Player</title>
    <script src="https://cdn.jsdelivr.net/npm/protobufjs@7.2.6/dist/protobuf.min.js"></script>
    <!-- Alpine.js for reactive UI -->
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>
    <!-- Leaflet for GPS minimap -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <style>
        :root {
            /* Brand colors */
            --tesla-red: #e82127;
            --tesla-red-light: #ff6b6b;
            --tesla-red-alt: #ff4444;
            --tesla-red-glow: rgba(232, 33, 39, 0.6);
            --tesla-red-bg: rgba(232, 33, 39, 0.1);
            --tesla-red-bg-subtle: rgba(232, 33, 39, 0.05);

            /* Status colors */
            --green: #22c55e;
            --green-light: #4ade80;
            --green-glow: rgba(34, 197, 94, 0.6);
            --yellow: #fbbf24;
            --orange: #f97316;
            --red-warning: #ef4444;

            /* Backgrounds */
            --bg-dark: #000;
            --bg-card: rgba(0, 0, 0, 0.7);
            --bg-card-solid: rgba(0, 0, 0, 0.9);
            --bg-card-deep: rgba(0, 0, 0, 0.95);
            --bg-overlay: rgba(0, 0, 0, 0.4);
            --bg-white-subtle: rgba(255, 255, 255, 0.02);
            --bg-white-dim: rgba(255, 255, 255, 0.1);
            --bg-white-light: rgba(255, 255, 255, 0.15);
            --bg-white-medium: rgba(255, 255, 255, 0.2);
            --bg-white-bright: rgba(255, 255, 255, 0.25);

            /* Borders */
            --border-dark: #222;
            --border-dim: #333;
            --border-muted: #555;
            --border-white-subtle: rgba(255, 255, 255, 0.05);
            --border-white-dim: rgba(255, 255, 255, 0.1);
            --border-white-light: rgba(255, 255, 255, 0.15);
            --border-white-medium: rgba(255, 255, 255, 0.2);
            --border-white-bright: rgba(255, 255, 255, 0.3);
            --border-white-strong: rgba(255, 255, 255, 0.4);

            /* Text colors */
            --text-muted: rgba(255, 255, 255, 0.4);
            --text-dim: rgba(255, 255, 255, 0.5);
            --text-secondary: rgba(255, 255, 255, 0.6);
            --text-tertiary: rgba(255, 255, 255, 0.7);
            --text-primary: rgba(255, 255, 255, 0.8);
            --text-gray: #666;
            --text-gray-light: #aaa;

            /* Transitions */
            --transition-fast: all 0.2s ease;
            --transition-normal: all 0.3s ease;

            /* Effects */
            --blur-standard: blur(12px);
            --blur-light: blur(4px);
            --shadow-text: 0 1px 3px rgba(0, 0, 0, 0.8);
            --shadow-button: 0 2px 8px rgba(0, 0, 0, 0.3);
            --shadow-dot: 0 1px 3px rgba(0, 0, 0, 0.5);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-dark);
            color: #fff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        /* Upload Screen */
        .upload-screen {
            text-align: center;
            padding: clamp(16px, 5vw, 40px);
        }

        .upload-screen h1 {
            font-size: 2.5rem;
            font-weight: 300;
            letter-spacing: 4px;
            background: linear-gradient(90deg, var(--tesla-red), var(--tesla-red-light));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 8px;
        }

        .upload-screen p {
            color: var(--text-gray);
            margin-bottom: 40px;
        }

        .upload-box {
            border: 2px dashed var(--border-dim);
            border-radius: 16px;
            padding: 60px clamp(24px, 8vw, 120px);
            cursor: pointer;
            transition: var(--transition-normal);
            background: var(--bg-white-subtle);
        }

        .upload-box:hover {
            border-color: var(--tesla-red);
            background: var(--tesla-red-bg-subtle);
        }

        .upload-box.dragover {
            border-color: var(--tesla-red);
            background: var(--tesla-red-bg);
            transform: scale(1.02);
        }

        .upload-icon {
            font-size: 64px;
            margin-bottom: 20px;
        }

        .upload-box h3 {
            font-weight: 400;
            font-size: 1.2rem;
            margin-bottom: 8px;
        }

        .upload-box span {
            color: var(--text-gray);
            font-size: 0.85rem;
        }

        #fileInput {
            display: none;
        }

        .loading-screen {
            display: none;
            text-align: center;
        }

        .loading-screen.active {
            display: block;
        }

        .spinner {
            width: 48px;
            height: 48px;
            border: 3px solid var(--border-dim);
            border-top-color: var(--tesla-red);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Video Container */
        .video-container {
            display: none;
            position: fixed;
            inset: 0;
            background: var(--bg-dark);
            overflow: hidden;
            flex-direction: column;
        }

        .video-container.active {
            display: flex;
        }

        .video-wrapper {
            flex: 1;
            min-height: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .video-content-box {
            position: relative;
            max-width: 100%;
            max-height: 100%;
            /* aspect-ratio set dynamically via JS */
        }

        .video-content-box video {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* HUD Overlay */
        .hud-overlay {
            position: absolute;
            inset: 0;
            pointer-events: none;
            padding: 20px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            z-index: 10;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            position: relative;
        }

        .camera-label {
            font-size: 0.75rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: var(--text-tertiary);
            text-shadow: var(--shadow-text);
        }


        .hud-bottom {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
        }

        /* HUD Card */
        .hud-card {
            background: var(--bg-card);
            backdrop-filter: var(--blur-standard);
            border: 1px solid var(--border-white-dim);
            border-radius: 12px;
            padding: 16px 20px;
        }

        .hud-card-title {
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: var(--text-dim);
            margin-bottom: 8px;
        }

        /* Speed and G-Force Container */
        .speed-gforce-container {
            display: flex;
            align-items: stretch;
            gap: clamp(8px, 2vw, 16px);
        }

        /* Minimal G-Force (dot, trail, and rings) */
        .gforce-minimal {
            position: relative;
            aspect-ratio: 1;
        }

        .gforce-minimal .gforce-ring {
            position: absolute;
            border: 1px solid var(--border-white-medium);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .gforce-minimal .gforce-ring.r1 {
            width: 33%;
            height: 33%;
        }

        .gforce-minimal .gforce-ring.r2 {
            width: 66%;
            height: 66%;
        }

        .gforce-minimal .gforce-ring.r3 {
            width: 100%;
            height: 100%;
        }

        .gforce-minimal .gforce-trail-canvas {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
        }

        .gforce-minimal .gforce-dot {
            position: absolute;
            width: 14px;
            height: 14px;
            background: radial-gradient(circle, var(--tesla-red-light) 0%, var(--tesla-red) 100%);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.05s ease-out;
            z-index: 2;
        }

        /* Speedometer - Vertical layout */
        .speedometer-hud {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 2px;
            background: transparent;
            backdrop-filter: none;
            border: none;
            padding: 0;
        }

        .speed-display {
            display: flex;
            align-items: baseline;
            gap: clamp(3px, 1vw, 6px);
            cursor: pointer;
            pointer-events: auto;
        }

        .speed-display:hover {
            opacity: 0.8;
        }

        .speed-number {
            font-size: clamp(1.8rem, 6vw, 4rem);
            font-weight: 500;
            line-height: 1;
            font-variant-numeric: tabular-nums;
            transition: color 0.3s ease;
        }

        .speed-unit {
            font-size: clamp(0.55rem, 1.5vw, 1rem);
            font-weight: 500;
            color: var(--text-primary);
        }

        /* Autopilot Status (below speed) */
        .autopilot-hud {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-top: clamp(6px, 1.5vw, 12px);
            font-size: clamp(0.6rem, 1.8vw, 0.9rem);
            color: var(--text-secondary);
        }

        .autopilot-hud .status-indicator {
            width: 6px;
            height: 6px;
        }

        .autopilot-hud .ap-label {
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        /* Speed Sparkline Path Styles */
        .speed-sparkline-path {
            fill: none;
            stroke-width: 2;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        .speed-sparkline-area {
            opacity: 0.25;
        }

        /* Vertical Pedal Bar (Tesla Energy Display style) */
        .pedal-bar-vertical {
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 6px;
            display: flex;
            flex-direction: column;
            z-index: 20;
        }

        .pedal-bar-vertical-top {
            flex: 1;
            position: relative;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            background: var(--bg-white-dim);
        }

        .pedal-bar-vertical-bottom {
            flex: 1;
            position: relative;
            background: var(--bg-white-dim);
        }

        .pedal-bar-vertical-throttle {
            width: 100%;
            background: linear-gradient(to top, var(--green), var(--green-light));
            box-shadow: 0 0 8px var(--green-glow);
            transition: height 0.05s ease-out;
        }

        .pedal-bar-vertical-brake {
            width: 100%;
            background: linear-gradient(to bottom, var(--tesla-red), var(--tesla-red-light));
            box-shadow: 0 0 8px var(--tesla-red-glow);
            transition: height 0.05s ease-out;
        }

        .pedal-bar-vertical-center {
            position: absolute;
            left: 0;
            top: 50%;
            width: 100%;
            height: 2px;
            background: var(--border-white-bright);
            transform: translateY(-50%);
            z-index: 21;
        }

        /* Pedals */
        .pedals-hud {
            min-width: 180px;
        }

        .pedal-row {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 12px;
        }

        .pedal-row:last-child {
            margin-bottom: 0;
        }

        .pedal-label {
            font-size: 0.75rem;
            width: 60px;
            color: var(--text-tertiary);
        }

        .pedal-bar-bg {
            flex: 1;
            height: 8px;
            background: var(--bg-white-dim);
            border-radius: 4px;
            overflow: hidden;
        }

        .pedal-bar {
            height: 100%;
            border-radius: 4px;
            transition: width 0.05s ease-out;
        }

        .pedal-bar.throttle {
            background: linear-gradient(90deg, var(--green), var(--green-light));
            box-shadow: 0 0 12px var(--green-glow);
        }

        .pedal-bar.brake {
            background: linear-gradient(90deg, var(--tesla-red), var(--tesla-red-light));
            box-shadow: 0 0 12px var(--tesla-red-glow);
        }

        .pedal-value {
            font-size: 0.8rem;
            width: 40px;
            text-align: right;
            font-variant-numeric: tabular-nums;
        }

        /* Status */
        .status-hud {
            min-width: 160px;
        }

        .status-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 12px;
            padding: 6px 0;
            border-bottom: 1px solid var(--border-white-subtle);
        }

        .status-row:last-child {
            border-bottom: none;
        }

        .status-label {
            font-size: 0.75rem;
            color: var(--text-dim);
        }

        .status-value {
            font-size: 0.85rem;
            font-weight: 500;
        }

        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 6px;
        }

        .status-indicator.active {
            background: var(--green-light);
            box-shadow: 0 0 8px var(--green-glow);
        }

        .status-indicator.inactive {
            background: var(--border-muted);
        }

        /* Controls Bar */
        .controls-bar {
            background: var(--bg-card-solid);
            backdrop-filter: var(--blur-standard);
            padding: 12px 20px;
            border-top: 1px solid var(--border-dark);
        }

        .scrubber-row {
            margin-bottom: 12px;
        }

        .controls-row {
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .play-btn {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            border: none;
            background: linear-gradient(135deg, var(--tesla-red), var(--tesla-red-alt));
            color: white;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: var(--transition-fast);
            box-shadow: 0 4px 16px var(--tesla-red-glow);
            flex-shrink: 0;
        }

        .play-btn:hover {
            transform: scale(1.05);
        }

        .playback-controls {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .frame-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            border: none;
            background: var(--bg-white-light);
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: var(--transition-fast);
            flex-shrink: 0;
        }

        .frame-btn:hover {
            background: var(--bg-white-bright);
            transform: scale(1.05);
        }

        .frame-btn:active {
            transform: scale(0.95);
        }

        .scrubber-container {
            width: 100%;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .time-display {
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 0.85rem;
            color: var(--text-secondary);
            flex-shrink: 0;
        }

        .scrubber {
            flex: 1;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: var(--bg-white-medium);
            border-radius: 2px;
            cursor: pointer;
        }

        .scrubber::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #fff;
            cursor: pointer;
            box-shadow: var(--shadow-button);
        }

        .download-btn {
            background: var(--bg-white-dim);
            border: 1px solid var(--border-white-medium);
            color: #fff;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: var(--transition-fast);
        }

        .download-btn:hover {
            background: var(--bg-white-medium);
            border-color: var(--border-white-strong);
        }

        .info-row {
            display: flex;
            justify-content: space-between;
            margin-top: 12px;
            font-size: 0.7rem;
            color: var(--text-muted);
        }

        /* Recording indicator */
        .rec-indicator {
            display: flex;
            align-items: center;
            gap: 6px;
            color: var(--tesla-red);
        }

        .rec-dot {
            width: 6px;
            height: 6px;
            background: var(--tesla-red);
            border-radius: 50%;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        /* Error message */
        .error-message {
            display: none;
            background: rgba(232, 33, 39, 0.2);
            border: 1px solid var(--tesla-red);
            border-radius: 8px;
            padding: 16px 20px;
            margin-top: 20px;
            max-width: 500px;
        }

        .error-message.active {
            display: block;
        }

        .error-message h4 {
            color: var(--tesla-red);
            margin-bottom: 8px;
        }

        .error-message p {
            font-size: 0.85rem;
            color: var(--text-gray-light);
        }

        /* Collapsible Drawer */
        .drawer-toggle {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 4px 8px;
            font-size: 0.75rem;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: color 0.2s ease;
            position: absolute;
            left: 0;
        }

        .drawer-toggle:hover {
            color: #fff;
        }

        .drawer-toggle .arrow {
            transition: transform 0.3s ease;
            font-size: 0.6rem;
        }

        .drawer-toggle.open .arrow {
            transform: rotate(180deg);
        }

        .drawer-container {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
            background: var(--bg-card-deep);
            border-top: 1px solid var(--border-dark);
        }

        .drawer-container.open {
            max-height: 400px;
        }

        /* Drawer Tabs */
        .drawer-tabs {
            display: flex;
            gap: 0;
            border-bottom: 1px solid var(--border-white-dim);
            padding: 0 12px;
            overflow-x: auto;
            scrollbar-width: none;
        }

        .drawer-tabs::-webkit-scrollbar {
            display: none;
        }

        .drawer-tab {
            background: none;
            border: none;
            color: var(--text-dim);
            padding: 10px 14px;
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            transition: var(--transition-fast);
            border-bottom: 2px solid transparent;
            white-space: nowrap;
            flex-shrink: 0;
        }

        .drawer-tab:hover {
            color: var(--text-primary);
        }

        .drawer-tab.active {
            color: var(--tesla-red);
            border-bottom-color: var(--tesla-red);
        }

        .drawer-tab.hidden {
            display: none;
        }

        .drawer-content {
            padding: 16px 20px;
            position: relative;
            max-height: 360px;
            overflow-y: auto;
        }

        /* Tab Panels */
        .tab-panel {
            display: none;
            flex-direction: column;
            gap: 8px;
        }

        .tab-panel.active {
            display: flex;
        }

        .drawer-status-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 16px;
            font-size: 0.85rem;
        }

        .drawer-status-label {
            color: var(--text-dim);
        }

        .drawer-status-value {
            font-weight: 500;
        }

        .drawer-info-row {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        .drawer-info-item {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .drawer-info-label {
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-muted);
        }

        .drawer-info-value {
            font-family: 'SF Mono', Monaco, monospace;
            color: var(--text-primary);
        }

        /* Drawer G-Force */
        .drawer-gforce {
            width: 160px;
            height: 160px;
        }

        /* G-Force Labels */
        .gforce-labels-container {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .gforce-axis-label {
            font-size: 0.6rem;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .gforce-axis-label.vertical {
            writing-mode: vertical-rl;
            text-orientation: mixed;
            transform: rotate(180deg);
        }

        .gforce-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }

        .gforce-ring-label {
            position: absolute;
            font-size: 0.5rem;
            color: var(--text-muted);
            pointer-events: none;
        }

        .gforce-ring-label.r1-label {
            top: 50%;
            right: calc(50% - 16.5% - 2px);
            transform: translateY(-50%);
        }

        .gforce-ring-label.r2-label {
            top: 50%;
            right: calc(50% - 33% - 2px);
            transform: translateY(-50%);
        }

        .gforce-ring-label.r3-label {
            top: 50%;
            right: calc(50% - 50% - 2px);
            transform: translateY(-50%);
        }

        .gforce-unit-label {
            font-size: 0.55rem;
            color: var(--text-muted);
            text-align: center;
            margin-top: 8px;
        }

        .gforce-panel-layout {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 16px;
        }

        .gforce-raw-values {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .gforce-raw-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .gforce-raw-label {
            font-size: 0.7rem;
            color: var(--text-dim);
            min-width: 50px;
        }

        .gforce-raw-value {
            font-family: 'SF Mono', Monaco, monospace;
            font-size: 0.85rem;
            color: var(--text-secondary);
            min-width: 60px;
            text-align: right;
        }

        /* Drawer Sparkline */
        .drawer-sparkline-container {
            display: flex;
            gap: 8px;
            min-height: 120px;
            height: 140px;
            width: 100%;
            max-width: 500px;
            flex-shrink: 0;
        }

        .sparkline-y-axis {
            display: flex;
            align-items: center;
            gap: 4px;
            flex-shrink: 0;
        }

        .sparkline-unit {
            font-size: 0.55rem;
            color: var(--text-muted);
            writing-mode: vertical-rl;
            transform: rotate(180deg);
            font-family: 'SF Mono', Monaco, monospace;
        }

        .sparkline-y-labels {
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            height: 100%;
            padding: 2px 0;
            font-size: 0.6rem;
            color: var(--text-muted);
            font-family: 'SF Mono', Monaco, monospace;
            text-align: right;
            min-width: 24px;
        }

        .sparkline-chart-wrapper {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
        }

        .sparkline-chart {
            flex: 1;
            position: relative;
            border-left: 1px solid var(--border-white-light);
            border-bottom: 1px solid var(--border-white-light);
        }

        .sparkline-chart .speed-sparkline {
            width: 100%;
            height: 100%;
            display: block;
        }

        .sparkline-gridline {
            stroke: var(--border-white-dim);
            stroke-width: 0.5;
            stroke-dasharray: 2, 2;
        }

        .sparkline-current-line {
            stroke: var(--tesla-red);
            stroke-width: 1.5;
            stroke-dasharray: 3, 2;
        }

        .sparkline-current-dot {
            fill: var(--tesla-red);
        }

        .sparkline-chart .sparkline-current-label {
            position: absolute;
            top: -2px;
            transform: translateX(-50%) translateY(-100%);
            font-size: 0.65rem;
            color: var(--tesla-red);
            font-family: 'SF Mono', Monaco, monospace;
            font-weight: 500;
            white-space: nowrap;
        }

        .sparkline-x-labels {
            display: flex;
            justify-content: space-between;
            padding-top: 4px;
            font-size: 0.55rem;
            color: var(--text-muted);
            font-family: 'SF Mono', Monaco, monospace;
        }

        /* ============================================ */
        /* GPS Minimap Styles (in drawer)              */
        /* ============================================ */
        .minimap-container {
            margin-bottom: 8px;
        }

        .minimap {
            width: 120px;
            height: 120px;
            border-radius: 8px;
            overflow: hidden;
            background: var(--bg-overlay);
            border: 1px solid var(--border-white-medium);
        }

        /* Semi-transparent map tiles */
        .minimap .leaflet-tile-pane {
            opacity: 0.6 !important;
        }

        /* Leaflet overrides for minimap */
        .minimap .leaflet-container {
            background: transparent !important;
        }

        .minimap .leaflet-control-attribution,
        .minimap .leaflet-control-zoom {
            display: none !important;
        }

        /* Vehicle marker */
        .vehicle-marker {
            background: transparent !important;
            border: none !important;
        }
        .vehicle-dot {
            width: 12px;
            height: 12px;
            background: var(--tesla-red);
            border: 2px solid white;
            border-radius: 50%;
            box-shadow: 0 0 8px var(--tesla-red-glow);
        }

        /* Hide minimap section when no GPS data */
        #minimapSection.no-gps {
            display: none;
        }

        /* ============================================ */
        /* Camera Navigation Styles (Carousel)         */
        /* ============================================ */
        .camera-navigation {
            position: absolute;
            inset: 0;
            pointer-events: none;
            z-index: 15;
        }

        .camera-nav-label {
            font-size: 0.65rem;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: var(--text-secondary);
            text-shadow: var(--shadow-text);
        }

        .camera-nav-bottom {
            position: absolute;
            bottom: clamp(8px, 3vw, 16px);
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            pointer-events: auto;
        }

        .camera-nav-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .nav-arrow {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: var(--bg-overlay);
            backdrop-filter: var(--blur-light);
            border: 1px solid var(--border-white-light);
            color: white;
            cursor: pointer;
            transition: var(--transition-fast);
            display: flex;
            align-items: center;
            justify-content: center;
            -webkit-tap-highlight-color: transparent;
        }

        .nav-arrow svg {
            width: 12px;
            height: 12px;
        }

        .nav-arrow:hover {
            background: rgba(0, 0, 0, 0.6);
            border-color: var(--border-white-bright);
        }

        .nav-arrow:active {
            transform: scale(0.95);
        }

        .nav-arrow:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .camera-dots {
            display: flex;
            gap: 10px;
        }

        .camera-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--border-white-strong);
            cursor: pointer;
            transition: var(--transition-fast);
            box-shadow: var(--shadow-dot);
            -webkit-tap-highlight-color: transparent;
        }

        .camera-dot.active {
            background: var(--tesla-red);
            transform: scale(1.25);
            box-shadow: 0 0 6px var(--tesla-red-glow);
        }

        .camera-dot:hover:not(.active) {
            background: var(--text-secondary);
        }

        /* Hide camera navigation when only one camera */
        .camera-navigation.single-camera {
            display: none;
        }
    </style>
</head>
<body x-data="telemetryApp()" @keydown.window="handleKeydown($event)">
    <!-- Upload Screen -->
    <div class="upload-screen" x-show="screen === 'upload'" x-cloak>
        <h1>TESLA TELEMETRY</h1>
        <p>Video Player with HUD Overlay</p>
        <div class="upload-box"
             @click="$refs.fileInput.click()"
             @dragover.prevent="isDragging = true"
             @dragleave="isDragging = false"
             @drop.prevent="handleDrop($event)"
             :class="{ dragover: isDragging }">
            <div class="upload-icon">ðŸŽ¬</div>
            <h3>Drop your Tesla dashcam MP4s here</h3>
            <span>Select multiple cameras (front, back, left, right) for multi-view</span>
            <input type="file" x-ref="fileInput" @change="handleFileSelect($event)" accept="video/mp4,video/*" multiple style="display:none">
        </div>
        <div class="error-message" :class="{ active: showError }">
            <h4>No telemetry found</h4>
            <p>This video doesn't contain SEI metadata. Make sure it was recorded on firmware 2025.44.25 or later with HW3+.</p>
        </div>
    </div>

    <!-- Loading Screen -->
    <div class="loading-screen" :class="{ active: screen === 'loading' }">
        <div class="spinner"></div>
        <p>Extracting telemetry data...</p>
    </div>

    <!-- Video Container with HUD -->
    <div class="video-container" :class="{ active: screen === 'video' }">
        <div class="video-wrapper">
            <div class="video-content-box" x-ref="videoContentBox">
                <video x-ref="video" playsinline @loadedmetadata="onVideoLoaded()" @play="onPlay()" @pause="onPause()" @ended="onEnded()" @seeked="onSeeked()"></video>

                <!-- Vertical Pedal Bar -->
                <div class="pedal-bar-vertical">
                    <div class="pedal-bar-vertical-top">
                        <div class="pedal-bar-vertical-throttle" :style="{ height: throttle + '%' }"></div>
                    </div>
                    <div class="pedal-bar-vertical-bottom">
                        <div class="pedal-bar-vertical-brake" :style="{ height: brakeOn ? '100%' : '0%' }"></div>
                    </div>
                    <div class="pedal-bar-vertical-center"></div>
                </div>

                <div class="hud-overlay">
                    <!-- Top Row with Speed Display -->
                    <div class="hud-top">
                        <div class="hud-card speedometer-hud">
                            <div class="speed-display" @click="useMetric = !useMetric" title="Click to toggle KM/H / MPH">
                                <span class="speed-number" :style="{ color: speedColor }" x-text="displaySpeed"></span>
                                <span class="speed-unit" x-text="useMetric ? 'KM/H' : 'MPH'"></span>
                            </div>
                            <div class="autopilot-hud">
                                <span class="status-indicator" :class="apActive ? 'active' : 'inactive'"></span>
                                <span class="ap-label" x-text="apStatus"></span>
                            </div>
                        </div>
                    </div>
                    <div class="hud-bottom"></div>
                </div>

                <!-- Camera Navigation -->
                <div class="camera-navigation" :class="{ 'single-camera': cameras.length <= 1 }">
                    <div class="camera-nav-bottom">
                        <div class="camera-nav-row">
                            <button class="nav-arrow" @click="switchCamera(currentCameraIndex - 1)" :disabled="currentCameraIndex === 0">
                                <svg viewBox="0 0 24 24" width="14" height="14" fill="currentColor"><path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"/></svg>
                            </button>
                            <div class="camera-dots">
                                <template x-for="(cam, i) in cameras" :key="i">
                                    <div class="camera-dot" :class="{ active: i === currentCameraIndex }" @click="switchCamera(i)" :title="cam.label"></div>
                                </template>
                            </div>
                            <button class="nav-arrow" @click="switchCamera(currentCameraIndex + 1)" :disabled="currentCameraIndex === cameras.length - 1">
                                <svg viewBox="0 0 24 24" width="14" height="14" fill="currentColor"><path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"/></svg>
                            </button>
                        </div>
                        <span class="camera-nav-label" x-text="currentCamera?.label || 'Camera'"></span>
                    </div>
                </div>
            </div>
        </div>

        <div class="controls-bar">
            <div class="scrubber-row">
                <div class="scrubber-container">
                    <input type="range" class="scrubber" min="0" :max="videoDuration" step="0.1" x-model="currentTime" @input="seekTo($event.target.value)">
                    <span class="time-display" x-text="timeDisplay"></span>
                </div>
            </div>
            <div class="controls-row">
                <button class="drawer-toggle" @click="drawerOpen = !drawerOpen" :class="{ open: drawerOpen }">
                    <span>Details</span>
                    <span class="arrow">â–¼</span>
                </button>
                <div class="playback-controls">
                    <button class="frame-btn" @click="stepFrame(-1)" title="Previous frame (,)">
                        <svg viewBox="0 0 24 24" width="14" height="14" fill="currentColor"><path d="M6 6h2v12H6zm3.5 6l8.5 6V6z"/></svg>
                    </button>
                    <button class="play-btn" @click="togglePlay()">
                        <svg x-show="!isPlaying" viewBox="0 0 24 24" width="18" height="18" fill="currentColor"><path d="M8 5v14l11-7z"/></svg>
                        <svg x-show="isPlaying" viewBox="0 0 24 24" width="18" height="18" fill="currentColor"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>
                    </button>
                    <button class="frame-btn" @click="stepFrame(1)" title="Next frame (.)">
                        <svg viewBox="0 0 24 24" width="14" height="14" fill="currentColor"><path d="M6 18l8.5-6L6 6v12zM16 6v12h2V6h-2z"/></svg>
                    </button>
                </div>
            </div>
        </div>

        <!-- Collapsible Drawer with Tabs -->
        <div class="drawer-container" :class="{ open: drawerOpen }">
            <div class="drawer-tabs">
                <button class="drawer-tab" :class="{ active: activeTab === 'gforce' }" @click="switchTab('gforce')">G-Force</button>
                <button class="drawer-tab" :class="{ active: activeTab === 'speed' }" @click="switchTab('speed')">Speed</button>
                <button class="drawer-tab" :class="{ active: activeTab === 'status' }" @click="switchTab('status')">Status</button>
                <button class="drawer-tab" :class="{ active: activeTab === 'playback' }" @click="switchTab('playback')">Playback</button>
                <button class="drawer-tab" :class="{ active: activeTab === 'map', hidden: !hasGPS }" @click="switchTab('map')">Map</button>
                <button class="drawer-tab" :class="{ active: activeTab === 'export' }" @click="switchTab('export')">Export</button>
            </div>
            <div class="drawer-content">
                <!-- G-Force Tab -->
                <div class="tab-panel" :class="{ active: activeTab === 'gforce' }">
                    <div class="gforce-panel-layout">
                        <div class="gforce-labels-container">
                            <span class="gforce-axis-label vertical">Left</span>
                            <div class="gforce-wrapper">
                                <span class="gforce-axis-label">Front</span>
                                <div class="gforce-minimal drawer-gforce">
                                    <div class="gforce-ring r1"></div>
                                    <div class="gforce-ring r2"></div>
                                    <div class="gforce-ring r3"></div>
                                    <span class="gforce-ring-label r1-label" x-text="gforceLabel1"></span>
                                    <span class="gforce-ring-label r2-label" x-text="gforceLabel2"></span>
                                    <span class="gforce-ring-label r3-label" x-text="gforceLabel3"></span>
                                    <canvas class="gforce-trail-canvas" x-ref="gforceCanvas"></canvas>
                                    <div class="gforce-dot" :style="gforceDotStyle"></div>
                                </div>
                                <span class="gforce-axis-label">Back</span>
                            </div>
                            <span class="gforce-axis-label vertical">Right</span>
                        </div>
                        <div class="gforce-raw-values">
                            <div class="gforce-raw-item">
                                <span class="gforce-raw-label">X (Lat)</span>
                                <span class="gforce-raw-value" x-text="gforceRawX"></span>
                            </div>
                            <div class="gforce-raw-item">
                                <span class="gforce-raw-label">Y (Lon)</span>
                                <span class="gforce-raw-value" x-text="gforceRawY"></span>
                            </div>
                            <div class="gforce-raw-item">
                                <span class="gforce-raw-label">Z (Vert)</span>
                                <span class="gforce-raw-value" x-text="gforceRawZ"></span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Speed History Tab -->
                <div class="tab-panel" :class="{ active: activeTab === 'speed' }">
                    <div class="drawer-sparkline-container">
                        <!-- Y-axis labels (HTML) -->
                        <div class="sparkline-y-axis">
                            <span class="sparkline-unit" x-text="useMetric ? 'km/h' : 'mph'"></span>
                            <div class="sparkline-y-labels">
                                <span x-text="sparklineMaxLabel"></span>
                                <span x-text="sparklineMidLabel"></span>
                                <span x-text="sparklineMinLabel"></span>
                            </div>
                        </div>
                        <!-- Chart area -->
                        <div class="sparkline-chart-wrapper">
                            <div class="sparkline-chart">
                                <svg class="speed-sparkline" viewBox="0 0 100 100" preserveAspectRatio="none">
                                    <defs>
                                        <linearGradient id="sparklineGradient" x1="0%" y1="0%" x2="100%" y2="0%" x-html="sparklineGradientStops"></linearGradient>
                                        <linearGradient id="sparklineAreaGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                                            <stop offset="0%" stop-color="#fff" stop-opacity="0.3" />
                                            <stop offset="100%" stop-color="#fff" stop-opacity="0" />
                                        </linearGradient>
                                    </defs>
                                    <!-- Gridlines (with 8% padding top/bottom) -->
                                    <line class="sparkline-gridline" x1="0" y1="8" x2="100" y2="8" />
                                    <line class="sparkline-gridline" x1="0" y1="50" x2="100" y2="50" />
                                    <line class="sparkline-gridline" x1="0" y1="92" x2="100" y2="92" />
                                    <!-- Chart paths -->
                                    <path class="speed-sparkline-area" :d="sparklineAreaPath" fill="url(#sparklineAreaGradient)" />
                                    <path class="speed-sparkline-path" :d="sparklinePath" stroke="url(#sparklineGradient)" />
                                    <!-- Current value indicator line and dot -->
                                    <template x-if="speedHistory.length > 0">
                                        <g>
                                            <line class="sparkline-current-line" :x1="sparklineCurrentX" y1="0" :x2="sparklineCurrentX" y2="100" />
                                            <circle class="sparkline-current-dot" :cx="sparklineCurrentX" :cy="sparklineCurrentY" r="3" />
                                        </g>
                                    </template>
                                </svg>
                                <!-- Current value label (HTML, positioned) -->
                                <span class="sparkline-current-label" :style="{ left: sparklineCurrentX + '%' }" x-text="sparklineCurrentValue" x-show="speedHistory.length > 0"></span>
                            </div>
                            <!-- X-axis labels -->
                            <div class="sparkline-x-labels">
                                <span x-text="sparklineTimeStart"></span>
                                <span>Now</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Status Tab -->
                <div class="tab-panel" :class="{ active: activeTab === 'status' }">
                    <div class="drawer-status-row">
                        <span class="drawer-status-label">Gear</span>
                        <span class="drawer-status-value" x-text="gear"></span>
                    </div>
                    <div class="drawer-status-row">
                        <span class="drawer-status-label">Steering</span>
                        <span class="drawer-status-value" x-text="steering + 'Â°'"></span>
                    </div>
                </div>

                <!-- Playback Tab -->
                <div class="tab-panel" :class="{ active: activeTab === 'playback' }">
                    <div class="drawer-info-item">
                        <span class="drawer-info-label">Frame</span>
                        <span class="drawer-info-value" x-text="frameInfo"></span>
                    </div>
                </div>

                <!-- Map Tab -->
                <div class="tab-panel" :class="{ active: activeTab === 'map', 'no-gps': !hasGPS }">
                    <div class="minimap-container">
                        <div class="minimap" x-ref="minimap"></div>
                    </div>
                    <div class="drawer-info-item">
                        <span class="drawer-info-label">Coordinates</span>
                        <span class="drawer-info-value" x-text="locationInfo"></span>
                    </div>
                </div>

                <!-- Export Tab -->
                <div class="tab-panel" :class="{ active: activeTab === 'export' }">
                    <button class="download-btn" @click="downloadCSV()">Download CSV</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // Tesla Dashcam SEI Extractor
        // Based on https://github.com/teslamotors/dashcam
        // ============================================

        const PROTO_SCHEMA = `
            syntax = "proto3";
            message SeiMetadata {
                uint32 version = 1;
                Gear gear_state = 2;
                uint64 frame_seq_no = 3;
                float vehicle_speed_mps = 4;
                float accelerator_pedal_position = 5;
                float steering_wheel_angle = 6;
                bool blinker_on_left = 7;
                bool blinker_on_right = 8;
                bool brake_applied = 9;
                AutopilotState autopilot_state = 10;
                double latitude_deg = 11;
                double longitude_deg = 12;
                double heading_deg = 13;
                double linear_acceleration_mps2_x = 14;
                double linear_acceleration_mps2_y = 15;
                double linear_acceleration_mps2_z = 16;
            }
            enum Gear { GEAR_PARK = 0; GEAR_DRIVE = 1; GEAR_REVERSE = 2; GEAR_NEUTRAL = 3; }
            enum AutopilotState { NONE = 0; SELF_DRIVING = 1; AUTOSTEER = 2; TACC = 3; }
        `;

        let SeiMetadata = null;
        async function initProtobuf() {
            SeiMetadata = protobuf.parse(PROTO_SCHEMA).root.lookupType('SeiMetadata');
        }

        // MP4 Box Parser
        class MP4Parser {
            constructor(buffer) {
                this.buffer = buffer;
                this.view = new DataView(buffer);
            }
            findBox(start, end, name) {
                let offset = start;
                while (offset < end) {
                    const size = this.view.getUint32(offset);
                    const type = this.getString(offset + 4, 4);
                    if (size === 0) break;
                    if (size === 1) { offset += 16; continue; }
                    if (type === name) return { offset, size, type };
                    offset += size;
                }
                return null;
            }
            getString(offset, length) {
                let str = '';
                for (let i = 0; i < length; i++) str += String.fromCharCode(this.view.getUint8(offset + i));
                return str;
            }
            getTimescaleAndDurations() {
                const moov = this.findBox(0, this.buffer.byteLength, 'moov');
                if (!moov) return null;
                const trak = this.findBox(moov.offset + 8, moov.offset + moov.size, 'trak');
                if (!trak) return null;
                const mdia = this.findBox(trak.offset + 8, trak.offset + trak.size, 'mdia');
                if (!mdia) return null;
                const mdhd = this.findBox(mdia.offset + 8, mdia.offset + mdia.size, 'mdhd');
                if (!mdhd) return null;
                const mdhdOffset = mdhd.offset + 8;
                const version = this.view.getUint8(mdhdOffset);
                const timescale = version === 0 ? this.view.getUint32(mdhdOffset + 12) : this.view.getUint32(mdhdOffset + 20);
                const minf = this.findBox(mdia.offset + 8, mdia.offset + mdia.size, 'minf');
                if (!minf) return { timescale, durations: [] };
                const stbl = this.findBox(minf.offset + 8, minf.offset + minf.size, 'stbl');
                if (!stbl) return { timescale, durations: [] };
                const stts = this.findBox(stbl.offset + 8, stbl.offset + stbl.size, 'stts');
                if (!stts) return { timescale, durations: [] };
                const sttsOffset = stts.offset + 8;
                const entryCount = this.view.getUint32(sttsOffset + 4);
                const durations = [];
                let pos = sttsOffset + 8;
                for (let i = 0; i < entryCount; i++) {
                    const sampleCount = this.view.getUint32(pos);
                    const sampleDelta = this.view.getUint32(pos + 4);
                    for (let j = 0; j < sampleCount; j++) durations.push(sampleDelta);
                    pos += 8;
                }
                return { timescale, durations };
            }
            getMdatInfo() { return this.findBox(0, this.buffer.byteLength, 'mdat'); }
        }

        function extractSEI(buffer, mdatOffset, mdatSize) {
            const view = new DataView(buffer);
            const seiMessages = [];
            let cursor = mdatOffset + 8;
            const end = mdatOffset + mdatSize;
            while (cursor + 4 <= end) {
                const nalSize = view.getUint32(cursor);
                cursor += 4;
                if (nalSize < 2 || cursor + nalSize > view.byteLength) { cursor += Math.max(nalSize, 0); continue; }
                const nalType = view.getUint8(cursor) & 0x1F;
                const payloadType = view.getUint8(cursor + 1);
                if (nalType === 6 && payloadType === 5) {
                    const decoded = decodeSEI(new Uint8Array(buffer.slice(cursor, cursor + nalSize)));
                    if (decoded) seiMessages.push(decoded);
                }
                cursor += nalSize;
            }
            return seiMessages;
        }
        function decodeSEI(nal) {
            if (!SeiMetadata || nal.length < 4) return null;

            try {
                // Search for magic marker: repeated 0x42 bytes followed by 0x69
                // Start at offset 3 (after NAL header + payload type + size byte)
                let i = 3;
                while (i < nal.length && nal[i] === 0x42) i++;

                // Validate: must have found at least one 0x42 and next byte must be 0x69
                if (i <= 3 || i + 1 >= nal.length || nal[i] !== 0x69) {
                    return null;
                }

                // Protobuf data starts after 0x69 marker, ends one byte before NAL end
                const protobufData = removeEmulationPrevention(
                    nal.subarray(i + 1, nal.length - 1)
                );

                if (protobufData.length < 4) return null;

                // Decode protobuf
                const message = SeiMetadata.decode(protobufData);
                return SeiMetadata.toObject(message, {
                    enums: String,
                    defaults: true
                });

            } catch (e) {
                return null;
            }
        }

        function removeEmulationPrevention(data) {
            const result = [];
            for (let i = 0; i < data.length; i++) {
                if (i >= 2 && data[i - 2] === 0x00 && data[i - 1] === 0x00 && data[i] === 0x03) continue;
                result.push(data[i]);
            }
            return new Uint8Array(result);
        }

        function detectCameraSource(filename) {
            const name = filename.toLowerCase().replace(/[-_]/g, ' ');
            const patterns = [
                { pattern: /left\s*pillar/, label: 'Left Pillar' },
                { pattern: /right\s*pillar/, label: 'Right Pillar' },
                { pattern: /left\s*repeater/, label: 'Left Repeater' },
                { pattern: /right\s*repeater/, label: 'Right Repeater' },
                { pattern: /\bleft\b/, label: 'Left' },
                { pattern: /\bright\b/, label: 'Right' },
                { pattern: /\bfront\b/, label: 'Front' },
                { pattern: /\bback\b/, label: 'Back' },
                { pattern: /\brear\b/, label: 'Rear' },
            ];
            for (const { pattern, label } of patterns) if (pattern.test(name)) return label;
            return null;
        }

        async function processSingleVideo(file) {
            const buffer = await file.arrayBuffer();
            const parser = new MP4Parser(buffer);
            const timing = parser.getTimescaleAndDurations();
            if (!timing) throw new Error('Could not parse video timing');
            const mdat = parser.getMdatInfo();
            if (!mdat) throw new Error('Could not find video data');
            const seiMessages = extractSEI(buffer, mdat.offset, mdat.size);
            if (seiMessages.length === 0) throw new Error('No telemetry data found');
            const timestamps = [];
            let time = 0;
            for (let i = 0; i < timing.durations.length; i++) {
                timestamps.push(time / timing.timescale);
                time += timing.durations[i];
            }
            return { file, url: URL.createObjectURL(file), label: detectCameraSource(file.name) || 'Unknown', telemetry: seiMessages, frameTimestamps: timestamps };
        }

        const SPARKLINE_POINTS = 60, GFORCE_TRAIL_LENGTH = 20;

        // GPS Minimap Class
        class GPSMinimap {
            constructor(container) {
                this.container = container;
                this.map = null;
                this.routeLine = null;
                this.vehicleMarker = null;
                this.gpsPoints = [];
                this.routeBounds = null;
                this.initialized = false;
            }
            initialize() {
                if (this.initialized || !this.container) return;
                try {
                    this.map = L.map(this.container, {
                        zoomControl: false, attributionControl: false, dragging: false,
                        scrollWheelZoom: false, doubleClickZoom: false, touchZoom: false, keyboard: false
                    }).setView([0, 0], 2);
                    L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', { maxZoom: 19, subdomains: 'abcd' }).addTo(this.map);
                    const vehicleIcon = L.divIcon({ className: 'vehicle-marker', html: '<div class="vehicle-dot"></div>', iconSize: [12, 12], iconAnchor: [6, 6] });
                    this.vehicleMarker = L.marker([0, 0], { icon: vehicleIcon });
                    this.routeLine = L.polyline([], { color: '#e82127', weight: 2, opacity: 0.8 });
                    this.initialized = true;
                } catch (e) { console.error('Failed to initialize minimap:', e); }
            }
            buildRoute(telemetryFrames) {
                if (!this.initialized || !this.map) return false;
                this.gpsPoints = telemetryFrames.filter(f => f.latitudeDeg && f.longitudeDeg && (f.latitudeDeg !== 0 || f.longitudeDeg !== 0)).map(f => [f.latitudeDeg, f.longitudeDeg]);
                if (this.gpsPoints.length === 0) return false;
                this.routeLine.setLatLngs(this.gpsPoints).addTo(this.map);
                this.vehicleMarker.setLatLng(this.gpsPoints[0]).addTo(this.map);
                this.routeBounds = this.routeLine.getBounds();
                setTimeout(() => { this.map.invalidateSize(); this.map.fitBounds(this.routeBounds, { padding: [15, 15] }); }, 100);
                return true;
            }
            updatePosition(lat, lng) {
                if (!this.initialized || !lat || !lng || (lat === 0 && lng === 0)) return;
                this.vehicleMarker.setLatLng([lat, lng]);
            }
            hasGPSData() { return this.gpsPoints.length > 0; }
        }

        // Alpine.js Application
        function telemetryApp() {
            return {
                // Screen state
                screen: 'upload',
                showError: false,
                isDragging: false,

                // Data
                cameras: [],
                currentCameraIndex: 0,
                currentFrame: 0,

                // UI state
                useMetric: true,
                drawerOpen: false,
                activeTab: 'gforce',
                isPlaying: false,
                currentTime: 0,
                videoDuration: 0,

                // Telemetry display values
                speedKmh: 0,
                throttle: 0,
                brakeOn: false,
                gX: 0, gY: 0, gZ: 0,
                apState: 'NONE',
                gearState: 'GEAR_DRIVE',
                steeringAngle: 0,
                lat: 0, lng: 0,

                // History for visualizations
                speedHistory: [],
                gforceHistory: [],
                _statsCache: null,

                // Runtime
                animationFrameId: null,
                gforceCtx: null,
                minimap: null,

                // Computed properties
                get currentCamera() { return this.cameras[this.currentCameraIndex]; },
                get telemetry() { return this.currentCamera?.telemetry || []; },
                get frameTimestamps() { return this.currentCamera?.frameTimestamps || []; },
                get currentFrameData() { return this.telemetry[this.currentFrame] || null; },

                get stats() {
                    if (!this._statsCache) {
                        let minSpeed = Infinity, maxSpeed = 0, maxGforce = 0;
                        for (const f of this.telemetry) {
                            const s = (f.vehicleSpeedMps || 0) * 3.6;
                            if (s < minSpeed) minSpeed = s;
                            if (s > maxSpeed) maxSpeed = s;
                            const gTotal = Math.sqrt((f.linearAccelerationMps2X || 0) ** 2 + (f.linearAccelerationMps2Y || 0) ** 2) / 9.81;
                            if (gTotal > maxGforce) maxGforce = gTotal;
                        }
                        this._statsCache = { minSpeed: minSpeed === Infinity ? 0 : minSpeed, maxSpeed: maxSpeed || 60, maxGforce: maxGforce || 1.0 };
                    }
                    return this._statsCache;
                },

                get hasGPS() {
                    return this.telemetry.some(f => f.latitudeDeg && f.longitudeDeg && (f.latitudeDeg !== 0 || f.longitudeDeg !== 0));
                },

                get displaySpeed() {
                    const speed = this.useMetric ? this.speedKmh : this.speedKmh * 0.621371;
                    return speed.toFixed(1);
                },

                get speedColor() {
                    const range = this.stats.maxSpeed - this.stats.minSpeed;
                    const norm = range > 0 ? Math.max(0, Math.min(1, (this.speedKmh - this.stats.minSpeed) / range)) : 0;
                    let r, g, b;
                    if (norm < 0.5) {
                        const t = norm * 2;
                        r = Math.round(34 + (251 - 34) * t);
                        g = Math.round(197 + (191 - 197) * t);
                        b = Math.round(94 + (36 - 94) * t);
                    } else {
                        const t = (norm - 0.5) * 2;
                        r = Math.round(251 + (239 - 251) * t);
                        g = Math.round(191 + (68 - 191) * t);
                        b = Math.round(36 + (68 - 36) * t);
                    }
                    return `rgb(${r}, ${g}, ${b})`;
                },

                get apActive() { return this.apState === 'AUTOSTEER' || this.apState === 'SELF_DRIVING' || this.apState === 'TACC'; },
                get apStatus() {
                    if (this.apState === 'AUTOSTEER') return 'AUTOSTEER';
                    if (this.apState === 'SELF_DRIVING') return 'FSD';
                    if (this.apState === 'TACC') return 'TACC';
                    return 'OFF';
                },

                get gear() { return { GEAR_PARK: 'P', GEAR_DRIVE: 'D', GEAR_REVERSE: 'R', GEAR_NEUTRAL: 'N' }[this.gearState] || 'D'; },
                get steering() { return this.steeringAngle.toFixed(1); },
                get frameInfo() { return `${this.currentFrame + 1} / ${this.telemetry.length}`; },
                get locationInfo() { return (this.lat !== 0 || this.lng !== 0) ? `${this.lat.toFixed(5)}, ${this.lng.toFixed(5)}` : '--'; },
                get timeDisplay() {
                    const fmt = (s) => `${Math.floor(s / 60)}:${Math.floor(s % 60).toString().padStart(2, '0')}`;
                    return `${fmt(this.currentTime)} / ${fmt(this.videoDuration)}`;
                },

                get gforceRawX() { return (this.gX / 9.81).toFixed(4) + 'g'; },
                get gforceRawY() { return (this.gY / 9.81).toFixed(4) + 'g'; },
                get gforceRawZ() { return (this.gZ / 9.81).toFixed(4) + 'g'; },
                get gforceLabel1() { return (this.stats.maxGforce / 3).toFixed(1) + 'g'; },
                get gforceLabel2() { return ((this.stats.maxGforce * 2) / 3).toFixed(1) + 'g'; },
                get gforceLabel3() { return this.stats.maxGforce.toFixed(1) + 'g'; },

                get gforceDotStyle() {
                    const maxG = this.stats.maxGforce || 1.0;
                    const x = 50 + (this.gX / 9.81 / maxG) * 45;
                    const y = 50 - (this.gY / 9.81 / maxG) * 45;
                    return { left: `${Math.max(5, Math.min(95, x))}%`, top: `${Math.max(5, Math.min(95, y))}%` };
                },

                get sparklinePath() {
                    if (this.speedHistory.length < 2) return '';
                    const range = this.stats.maxSpeed - this.stats.minSpeed;
                    const pad = 8; // padding top/bottom
                    const pts = this.speedHistory.map((s, i) => {
                        const x = (i / (SPARKLINE_POINTS - 1)) * 100;
                        const norm = range > 0 ? (s - this.stats.minSpeed) / range : 0.5;
                        const y = pad + (1 - norm) * (100 - pad * 2);
                        return `${x},${y}`;
                    });
                    return `M ${pts.join(' L ')}`;
                },

                get sparklineAreaPath() {
                    if (this.speedHistory.length < 2) return '';
                    const pad = 8;
                    return `${this.sparklinePath} L 100,${100 - pad} L 0,${100 - pad} Z`;
                },

                get sparklineGradientStops() {
                    const s = this.speedHistory[this.speedHistory.length - 1] || 0;
                    if (s < 40) return '<stop offset="0%" stop-color="rgba(255,255,255,0.3)"/><stop offset="100%" stop-color="#fff"/>';
                    if (s < 80) return '<stop offset="0%" stop-color="rgba(255,255,255,0.3)"/><stop offset="100%" stop-color="#fbbf24"/>';
                    if (s < 120) return '<stop offset="0%" stop-color="rgba(251,191,36,0.3)"/><stop offset="100%" stop-color="#f97316"/>';
                    return '<stop offset="0%" stop-color="rgba(249,115,22,0.3)"/><stop offset="100%" stop-color="#ef4444"/>';
                },

                // Sparkline axis labels
                get sparklineMaxLabel() {
                    const maxSpeed = this.useMetric ? this.stats.maxSpeed : this.stats.maxSpeed * 0.621371;
                    return Math.round(maxSpeed);
                },

                get sparklineMidLabel() {
                    const midSpeed = (this.stats.maxSpeed + this.stats.minSpeed) / 2;
                    const displaySpeed = this.useMetric ? midSpeed : midSpeed * 0.621371;
                    return Math.round(displaySpeed);
                },

                get sparklineMinLabel() {
                    const minSpeed = this.useMetric ? this.stats.minSpeed : this.stats.minSpeed * 0.621371;
                    return Math.round(minSpeed);
                },

                get sparklineTimeStart() {
                    const secondsAgo = Math.round(SPARKLINE_POINTS / 30); // Assuming ~30fps
                    return `-${secondsAgo}s`;
                },

                // Current value indicator position (0-100 scale)
                get sparklineCurrentX() {
                    if (this.speedHistory.length === 0) return 0;
                    return ((this.speedHistory.length - 1) / (SPARKLINE_POINTS - 1)) * 100;
                },

                get sparklineCurrentY() {
                    if (this.speedHistory.length === 0) return 50;
                    const range = this.stats.maxSpeed - this.stats.minSpeed;
                    const pad = 8;
                    const currentSpeed = this.speedHistory[this.speedHistory.length - 1] || 0;
                    const norm = range > 0 ? (currentSpeed - this.stats.minSpeed) / range : 0.5;
                    return pad + (1 - norm) * (100 - pad * 2);
                },

                get sparklineCurrentValue() {
                    const currentSpeed = this.speedHistory[this.speedHistory.length - 1] || 0;
                    const displaySpeed = this.useMetric ? currentSpeed : currentSpeed * 0.621371;
                    return Math.round(displaySpeed);
                },

                // Event handlers
                handleFileSelect(e) { this.processFiles(Array.from(e.target.files)); },
                handleDrop(e) { this.isDragging = false; this.processFiles(Array.from(e.dataTransfer.files).filter(f => f.type.startsWith('video/'))); },

                async processFiles(files) {
                    if (files.length === 0) return;
                    this.showError = false;
                    this.screen = 'loading';
                    try {
                        await initProtobuf();
                        this.cameras = [];
                        for (const file of files) {
                            try { this.cameras.push(await processSingleVideo(file)); }
                            catch (e) { console.warn(`Failed to process ${file.name}:`, e.message); }
                        }
                        if (this.cameras.length === 0) throw new Error('No valid telemetry');
                        const order = ['Front', 'Left Repeater', 'Left Pillar', 'Left', 'Back', 'Rear', 'Right', 'Right Pillar', 'Right Repeater'];
                        this.cameras.sort((a, b) => {
                            if (a.label === 'Unknown') return 1;
                            if (b.label === 'Unknown') return -1;
                            return (order.findIndex(c => a.label.includes(c)) ?? 999) - (order.findIndex(c => b.label.includes(c)) ?? 999);
                        });
                        this.currentCameraIndex = 0;
                        this._statsCache = null;
                        this.$refs.video.src = this.currentCamera.url;
                    } catch (e) {
                        console.error('Error:', e);
                        this.screen = 'upload';
                        this.showError = true;
                    }
                },

                onVideoLoaded() {
                    this.screen = 'video';
                    this.videoDuration = this.$refs.video.duration;
                    this.$refs.videoContentBox.style.aspectRatio = `${this.$refs.video.videoWidth} / ${this.$refs.video.videoHeight}`;
                    this.initGforceCanvas();
                    this.initMinimap();
                    this.updateFrame(0);
                },

                initGforceCanvas() {
                    const canvas = this.$refs.gforceCanvas;
                    if (canvas) {
                        this.gforceCtx = canvas.getContext('2d');
                        const resize = () => { const s = canvas.parentElement?.offsetHeight || 150; canvas.width = canvas.height = s; };
                        resize();
                        window.addEventListener('resize', resize);
                    }
                },

                initMinimap() {
                    this.minimap = new GPSMinimap(this.$refs.minimap);
                    this.minimap.initialize();
                    for (const cam of this.cameras) {
                        if (cam.telemetry.some(f => f.latitudeDeg && f.longitudeDeg && (f.latitudeDeg !== 0 || f.longitudeDeg !== 0))) {
                            this.minimap.buildRoute(cam.telemetry);
                            break;
                        }
                    }
                },

                onPlay() {
                    this.isPlaying = true;
                    const loop = () => {
                        this.currentTime = this.$refs.video.currentTime;
                        this.updateFrame(this.findFrameAtTime(this.currentTime));
                        this.animationFrameId = requestAnimationFrame(loop);
                    };
                    loop();
                },

                onPause() {
                    this.isPlaying = false;
                    if (this.animationFrameId) { cancelAnimationFrame(this.animationFrameId); this.animationFrameId = null; }
                    this.currentTime = this.$refs.video.currentTime;
                    this.updateFrame(this.findFrameAtTime(this.currentTime));
                },

                onEnded() { this.isPlaying = false; if (this.animationFrameId) { cancelAnimationFrame(this.animationFrameId); this.animationFrameId = null; } },

                onSeeked() {
                    this.currentTime = this.$refs.video.currentTime;
                    const frame = this.findFrameAtTime(this.currentTime);
                    this.rebuildHistory(frame);
                    this.updateFrame(frame);
                },

                togglePlay() {
                    if (this.$refs.video.paused) this.$refs.video.play();
                    else this.$refs.video.pause();
                },

                stepFrame(dir) {
                    this.$refs.video.pause();
                    this.$refs.video.currentTime = Math.max(0, Math.min(this.videoDuration, this.$refs.video.currentTime + dir / 30));
                },

                seekTo(time) { this.$refs.video.currentTime = parseFloat(time); },

                switchCamera(index) {
                    if (index < 0 || index >= this.cameras.length) return;
                    const wasPlaying = this.isPlaying;
                    const time = this.$refs.video.currentTime;
                    this.currentCameraIndex = index;
                    this._statsCache = null;
                    this.$refs.video.src = this.currentCamera.url;
                    this.$refs.video.onloadedmetadata = () => {
                        this.$refs.video.currentTime = Math.min(time, this.$refs.video.duration);
                        this.videoDuration = this.$refs.video.duration;
                        if (wasPlaying) this.$refs.video.play();
                        this.rebuildHistory(this.findFrameAtTime(this.$refs.video.currentTime));
                    };
                },

                switchTab(tab) {
                    this.activeTab = tab;
                    if (tab === 'map' && this.minimap?.map) {
                        setTimeout(() => { this.minimap.map.invalidateSize(); if (this.minimap.routeBounds) this.minimap.map.fitBounds(this.minimap.routeBounds, { padding: [15, 15] }); }, 50);
                    }
                    if (tab === 'gforce') this.drawGforceTrail();
                },

                findFrameAtTime(time) {
                    const ts = this.frameTimestamps;
                    let low = 0, high = ts.length - 1;
                    while (low < high) {
                        const mid = Math.floor((low + high + 1) / 2);
                        if (ts[mid] <= time) low = mid; else high = mid - 1;
                    }
                    return Math.min(low, this.telemetry.length - 1);
                },

                updateFrame(frameIndex) {
                    this.currentFrame = Math.max(0, Math.min(frameIndex, this.telemetry.length - 1));
                    const d = this.currentFrameData;
                    if (!d) return;

                    this.speedKmh = (d.vehicleSpeedMps || 0) * 3.6;
                    this.throttle = Math.min(Math.max(d.acceleratorPedalPosition || 0, 0), 100);
                    this.brakeOn = d.brakeApplied === true;
                    this.gX = d.linearAccelerationMps2X || 0;
                    this.gY = d.linearAccelerationMps2Y || 0;
                    this.gZ = d.linearAccelerationMps2Z || 0;
                    this.apState = d.autopilotState || 'NONE';
                    this.gearState = d.gearState || 'GEAR_DRIVE';
                    this.steeringAngle = d.steeringWheelAngle || 0;
                    this.lat = d.latitudeDeg || 0;
                    this.lng = d.longitudeDeg || 0;

                    this.speedHistory.push(this.speedKmh);
                    if (this.speedHistory.length > SPARKLINE_POINTS) this.speedHistory.shift();
                    this.gforceHistory.push({ x: this.gX, y: this.gY });
                    if (this.gforceHistory.length > GFORCE_TRAIL_LENGTH) this.gforceHistory.shift();
                    this.drawGforceTrail();

                    if (this.minimap?.hasGPSData()) this.minimap.updatePosition(this.lat, this.lng);
                },

                rebuildHistory(fromFrame) {
                    this.speedHistory = [];
                    this.gforceHistory = [];
                    const start = Math.max(0, fromFrame - SPARKLINE_POINTS);
                    for (let i = start; i <= fromFrame && i < this.telemetry.length; i++) {
                        const d = this.telemetry[i];
                        this.speedHistory.push((d.vehicleSpeedMps || 0) * 3.6);
                        this.gforceHistory.push({ x: d.linearAccelerationMps2X || 0, y: d.linearAccelerationMps2Y || 0 });
                    }
                },

                drawGforceTrail() {
                    if (!this.gforceCtx || this.gforceHistory.length < 2) return;
                    const ctx = this.gforceCtx, canvas = ctx.canvas;
                    const cx = canvas.width / 2, cy = canvas.height / 2;
                    const maxG = this.stats.maxGforce || 1.0, scale = (canvas.width / 2) * 0.9;
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.beginPath();
                    for (let i = 0; i < this.gforceHistory.length; i++) {
                        const p = this.gforceHistory[i];
                        const x = cx + (p.x / 9.81 / maxG) * scale;
                        const y = cy - (p.y / 9.81 / maxG) * scale;
                        if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                    }
                    const grad = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
                    grad.addColorStop(0, 'rgba(232, 33, 39, 0)');
                    grad.addColorStop(1, 'rgba(232, 33, 39, 0.8)');
                    ctx.strokeStyle = grad;
                    ctx.lineWidth = 2;
                    ctx.lineCap = 'round';
                    ctx.stroke();
                    for (let i = 0; i < this.gforceHistory.length; i++) {
                        const p = this.gforceHistory[i];
                        const x = cx + (p.x / 9.81 / maxG) * scale;
                        const y = cy - (p.y / 9.81 / maxG) * scale;
                        ctx.beginPath();
                        ctx.arc(x, y, 1.5 + (i / this.gforceHistory.length) * 2.5, 0, Math.PI * 2);
                        ctx.fillStyle = `rgba(232, 33, 39, ${(i / this.gforceHistory.length) * 0.5})`;
                        ctx.fill();
                    }
                },

                handleKeydown(e) {
                    if (this.screen !== 'video') return;
                    if (e.code === 'Space') { e.preventDefault(); this.togglePlay(); }
                    else if (e.code === 'ArrowLeft') this.$refs.video.currentTime = Math.max(0, this.$refs.video.currentTime - 1);
                    else if (e.code === 'ArrowRight') this.$refs.video.currentTime = Math.min(this.videoDuration, this.$refs.video.currentTime + 1);
                    else if (e.code === 'Comma') this.stepFrame(-1);
                    else if (e.code === 'Period') this.stepFrame(1);
                    else if (e.code === 'BracketLeft') this.switchCamera(this.currentCameraIndex - 1);
                    else if (e.code === 'BracketRight') this.switchCamera(this.currentCameraIndex + 1);
                    else if (e.key >= '1' && e.key <= '9') { const i = parseInt(e.key) - 1; if (i < this.cameras.length) this.switchCamera(i); }
                },

                downloadCSV() {
                    if (this.telemetry.length === 0) { alert('No telemetry data'); return; }
                    const headers = ['frame_seq_no','timestamp_sec','version','gear_state','vehicle_speed_mps','accelerator_pedal_position','steering_wheel_angle','blinker_on_left','blinker_on_right','brake_applied','autopilot_state','latitude_deg','longitude_deg','heading_deg','linear_acceleration_mps2_x','linear_acceleration_mps2_y','linear_acceleration_mps2_z'];
                    const rows = [headers.join(',')];
                    for (let i = 0; i < this.telemetry.length; i++) {
                        const d = this.telemetry[i], ts = this.frameTimestamps[i];
                        rows.push([d.frameSeqNo||'',ts?.toFixed(6)||'',d.version||'',d.gearState||'',d.vehicleSpeedMps||0,d.acceleratorPedalPosition||0,d.steeringWheelAngle||0,d.blinkerOnLeft||false,d.blinkerOnRight||false,d.brakeApplied||false,d.autopilotState||'',d.latitudeDeg||0,d.longitudeDeg||0,d.headingDeg||0,d.linearAccelerationMps2X||0,d.linearAccelerationMps2Y||0,d.linearAccelerationMps2Z||0].join(','));
                    }
                    const blob = new Blob([rows.join('\n')], { type: 'text/csv' });
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    link.download = 'telemetry_extracted.csv';
                    link.click();
                    URL.revokeObjectURL(link.href);
                }
            };
        }
    </script>
</body>
</html>
